//
// Created by a_mod on 06.01.2019.
//

#include <Lexical/Tokens/WhileToken.h>
#include "LexicalAnalysis.h"
#include <fstream>
#include <iostream>
#include <Lexical/Tokens/EOSToken.h>
#include <Logger/Logger.h>

#include <Lexical/Tokens/IdToken.h>
#include <Lexical/Tokens/VarToken.h>
#include <Lexical/Tokens/ClosedBracketToken.h>
#include <Lexical/Tokens/OpenBracketToken.h>
#include <Lexical/Tokens/SallocToken.h>
#include <Lexical/Tokens/ModuloToken.h>
#include <Lexical/Tokens/SyscallToken.h>
#include <Lexical/Tokens/AssignToken.h>
#include <Lexical/Tokens/DeclToken.h>
#include <Lexical/Tokens/ExitToken.h>
#include <Lexical/Tokens/IndentToken.h>
#include <Lexical/Tokens/FunctionToken.h>
#include <Lexical/Tokens/ForToken.h>
#include <Lexical/Tokens/ElifToken.h>
#include <Lexical/Tokens/ColonToken.h>
#include <Lexical/Tokens/ExtentToken.h>
#include <Lexical/Tokens/CommaToken.h>
#include <Lexical/Tokens/ReturnToken.h>
#include <General/builtinTypes.h>
#include <Lexical/Tokens/IfToken.h>
#include <Lexical/Tokens/ComparisionToken.h>
#include <Lexical/Tokens/NotToken.h>
#include <Lexical/Tokens/ElseToken.h>
#include <Lexical/Tokens/ArrowToken.h>
#include <Lexical/Tokens/PlusToken.h>
#include <Lexical/Tokens/StarToken.h>
#include <Lexical/Tokens/MinusToken.h>
#include <Lexical/Tokens/OpenCurlyToken.h>
#include <Lexical/Tokens/ClosedCurlyToken.h>
#include <Lexical/Tokens/SlashToken.h>
#include <Lexical/Tokens/DotToken.h>
#include <Lexical/Tokens/DoubleQuoteToken.h>
#include <Lexical/Tokens/TextToken.h>
#include <Lexical/Tokens/QuoteToken.h>
#include <Lexical/Tokens/ImportToken.h>
#include <Error/SyntaxError.h>

bool contains(const std::string &str, std::vector<std::string> options) {
    for (auto const &option : options) {
        if (str == option)
            return true;
    }
    return false;
}

bool contains(char c, std::vector<std::string> options) {
    for (auto const &option : options) {
        if (c == option[0])
            return true;
    }
    return false;
}


ACC::LexicalAnalysis::LexicalAnalysis(std::string path) {
    indentList.push_back(0);
    refCount++;
    std::ifstream fs;
    fs.open(path);
    this->document = std::string((std::istreambuf_iterator<char>(fs)), std::istreambuf_iterator<char>());

    LOG.createHeading("Original Input being Lexically Analysed:");
    LOG() << this->document << std::endl;

    analyse();
    postProcessDocument();

}

ACC::LexicalAnalysis::~LexicalAnalysis() {
    refCount--;
    if (refCount != 0)
        return;

    for (const auto &it : tokens)
        delete it;
}

void ACC::LexicalAnalysis::postProcessDocument() {
    for (size_t i = 1; i < indentList.size(); i++) {
        tokens.push_back(new ExtentToken(0));
    }
}

void ACC::LexicalAnalysis::printToken() {
    LOG.createHeading("Tokens generated by the Lexical Analysis:");
    int prefix = 0;
    std::string out;
    for (auto token : tokens) {
        if (token->id == Symbol::INDENT)
            prefix += 4;
        else if (token->id == Symbol::EXTENT)
            prefix -= 4;
        if (prefix < 0)
            out += "[[[NEGATIVE INDEX]]]" + token->getIdentifier() + "\n";
        else
            out += std::string(prefix, ' ') + token->getIdentifier() + "\n";
    }
    LOG() << out;
    std::ofstream os("./debug.txt");
    os << out;
    os.close();
}

const std::vector<ACC::IToken *, std::allocator<ACC::IToken *>>::iterator ACC::LexicalAnalysis::begin() {
    return tokens.begin();
}

const std::vector<ACC::IToken *, std::allocator<ACC::IToken *>>::iterator ACC::LexicalAnalysis::end() {
    return tokens.end();
}

const std::vector<ACC::IToken *> &ACC::LexicalAnalysis::data() {
    return tokens;
}

void ACC::LexicalAnalysis::addZeroExit() {
    tokens.push_back(new ExitToken(0));
    tokens.push_back(new TextToken("0", 0));
    tokens.push_back(new EOSToken(0));
}

int ACC::LexicalAnalysis::readDepth(LineCountingPosition &pos) {
    int newGap = 0;
    while (contains(document.at(pos), {" ", "\n", "\r"})) {
        if (document.at(pos) == '\n') {
            newGap = 0;
        } else if (document.at(pos) == ' ')
            newGap++;
        ++pos;
        if (pos >= document.size())
            return 0;
    }
    return newGap;
}

void ACC::LexicalAnalysis::analyse() {
    std::vector<std::string> lines;
    findLines(lines);

    LineCountingPosition idx(document);
    std::string buffer;

    while (idx < document.size()) {

        if (contains(document[idx], {"\n", "\r"})) {
            idx++;
            checkIndent(idx);
            continue;
        }

        buffer = loadBuffer(idx);
        idx++;

        if (!stringMode && buffer[0] == ' ')
            buffer = buffer.substr(1, buffer.size());


        if (checkSpecial(buffer, idx, lines))
            continue;

        if (checkKeyword(buffer, idx, lines))
            continue;

        if (!buffer.empty()) {
            tokens.push_back(new TextToken(buffer, idx.lineNum));
            tokens.at(tokens.size() - 1)->lineContent = lines.at(idx.lineNum - 1);
        }
    }
}

void ACC::LexicalAnalysis::checkIndent(LineCountingPosition &idx) {
    int newDepth = readDepth(idx);
    if (newDepth > depth) {
        tokens.push_back(new IndentToken(idx.lineNum));
        indentList.push_back(newDepth);
    } else if (newDepth < depth) {
        while (indentList.at(indentList.size() - 1) > newDepth) {
            tokens.push_back(new ExtentToken(idx.lineNum));
            indentList.pop_back();
        }
        //popScope();
    }
    depth = newDepth;
}

bool ACC::LexicalAnalysis::checkSpecial(const std::string &buffer, LineCountingPosition idx,
                                        const std::vector<std::string> &lines) {

    if (buffer == "!=")
        tokens.push_back(new ComparisionToken(ComparisionTokenKind::NotEqual, idx.lineNum));

    else if (buffer == "<=")
        tokens.push_back(new ComparisionToken(ComparisionTokenKind::LessEqual, idx.lineNum));

    else if (buffer == ">=")
        tokens.push_back(new ComparisionToken(ComparisionTokenKind::GreaterEqual, idx.lineNum));

    else if (buffer == "==")
        tokens.push_back(new ComparisionToken(ComparisionTokenKind::Equal, idx.lineNum));

    else if (buffer == "->")
        tokens.push_back(new ArrowToken(idx.lineNum));

    else if (buffer == ":")
        tokens.push_back(new ColonToken(idx.lineNum));

    else if (buffer == ";")
        tokens.push_back(new EOSToken(idx.lineNum));

    else if (buffer == "{")
        tokens.push_back(new OpenCurlyToken(idx.lineNum));

    else if (buffer == "}")
        tokens.push_back(new ClosedCurlyToken(idx.lineNum));

    else if (buffer == "!")
        tokens.push_back(new NotToken(idx.lineNum));

    else if (buffer == ".")
        tokens.push_back(new DotToken(idx.lineNum));

    else if (buffer == "%")
        tokens.push_back(new ModuloToken(idx.lineNum));

    else if (buffer == "<")
        tokens.push_back(new ComparisionToken(ComparisionTokenKind::Less, idx.lineNum));

    else if (buffer == ">")
        tokens.push_back(new ComparisionToken(ComparisionTokenKind::Greater, idx.lineNum));

    else if (buffer == "\"") {
        tokens.push_back(new DoubleQuoteToken(idx.lineNum));
        stringMode = !stringMode;
    }
    else if (buffer == "'") {
        tokens.push_back(new QuoteToken(idx.lineNum));
        stringMode = !stringMode;
    }

    else if (buffer == ",")
        tokens.push_back(new CommaToken(idx.lineNum));

    else if (buffer == "(")
        tokens.push_back(new OpenBracketToken(idx.lineNum));

    else if (buffer == ")")
        tokens.push_back(new ClosedBracketToken(idx.lineNum));

    else if (buffer == "+")
        tokens.push_back(new PlusToken(idx.lineNum));

    else if (buffer == "-")
        tokens.push_back(new MinusToken(idx.lineNum));

    else if (buffer == "*")
        tokens.push_back(new StarToken(idx.lineNum));

    else if (buffer == "/")
        tokens.push_back(new SlashToken(idx.lineNum));

    else if (buffer == ",")
        tokens.push_back(new CommaToken(idx.lineNum));

    else if (buffer == "=")
        tokens.push_back(new AssignToken(idx.lineNum));

    else
        return false;

    tokens.at(tokens.size() - 1)->lineContent = lines.at(idx.lineNum - 1);

    return true;
}

bool ACC::LexicalAnalysis::checkKeyword(std::string const &buffer, LineCountingPosition idx,
                                        const std::vector<std::string> &lines) {
    if (buffer == "fn")
        tokens.push_back(new FunctionToken(idx.lineNum));

    else if (buffer == "else")
        tokens.push_back(new ElseToken(idx.lineNum));

    else if (buffer == "elif")
        tokens.push_back(new ElifToken(idx.lineNum));

    else if (buffer == "exit")
        tokens.push_back(new ExitToken(idx.lineNum));

    else if (buffer == "for")
        tokens.push_back(new ForToken(idx.lineNum));

    else if (buffer == "if")
        tokens.push_back(new IfToken(idx.lineNum));

    else if (buffer == "import")
        tokens.push_back(new ImportToken(idx.lineNum));

    else if (buffer == "return")
        tokens.push_back(new ReturnToken(idx.lineNum));

    else if (buffer == "salloc")
        tokens.push_back(new SallocToken(idx.lineNum));

    else if (buffer == "syscall")
        tokens.push_back(new SyscallToken(idx.lineNum));

    else if (buffer == "var")
        tokens.push_back(new VarToken(idx.lineNum));

    else if (buffer == "while")
        tokens.push_back(new WhileToken(idx.lineNum));

    else
        return false;

    tokens.at(tokens.size() - 1)->lineContent = lines.at(idx.lineNum - 1);

    return true;
}

std::string ACC::LexicalAnalysis::loadBuffer(LineCountingPosition &idx) {
    const std::vector<std::string> specialTokens = {"\"", ";", "\n", "\r", "(", ")", "+", "-", "*", "/", ",", "=",
                                                    "<", ">", "!", ":", "\'", "\"", "%", ",", "{", "}", ".", " "};


    std::string buffer;
    if(stringMode && !contains(document[idx], {"'", "\""})){
        while (idx < document.size() && !contains(document[idx], {"'", "\""})) {
            if (document[idx] == '\\') {

                if (document[idx + 1] == 'n')
                    buffer += "\n";

                else if (document[idx + 1] == '"')
                    buffer += "\"";

                else if (document[idx + 1] == '\'')
                    buffer += "'";

                else if (document[idx + 1] == 'r')
                    buffer += "\r";

                else if (document[idx + 1] == '\\')
                    buffer += "\\";

                else
                    buffer += "\u26A0"; // TODO: ERROR REPORTING

                idx++;
                idx++;
            }
            else{
                buffer += document[idx];
                idx++;
            }
        }
        idx--;
    }
    else if (contains(document[idx], specialTokens)) {

        buffer += document[idx];

        // Most special tokens that can be grouped are only on character (e.g. (, !, " ) wide, we do need to check for
        // some exceptions though.

        if (idx + 1 >= document.size())
            return buffer;

        const std::string toTest = std::string() + document[idx] + document[idx + 1];

        if (toTest == "->") {
            buffer = "->";
            idx++;
        } else if (toTest == "<=") {
            buffer = "<=";
            idx++;

        } else if (toTest == ">=") {
            buffer = ">=";
            idx++;
        } else if (toTest == "==") {
            buffer = "==";
            idx++;
        } else if (toTest == "!=") {
            buffer = "!=";
            idx++;
        }
    } else {
        while (idx < document.size() && !contains(document[idx], specialTokens)) {
            buffer += document[idx];
            idx++;

        }
        idx--;
    }

    return buffer;
}

ACC::LexicalAnalysis::LexicalAnalysis(const ACC::LexicalAnalysis &other) : tokens(other.tokens),
                                                                           document(other.document),
                                                                           refCount(other.refCount),
                                                                           indentList(other.indentList),
                                                                           depth(other.depth) {
    refCount++;
}

ACC::IToken *ACC::LexicalAnalysis::at(size_t idx) {
    return tokens.at(idx);
}

size_t ACC::LexicalAnalysis::size() {
    return tokens.size();
}

void ACC::LexicalAnalysis::findLines(std::vector<std::string> &lines) {
    long prevIdx = -1;
    for (size_t i = 0; i < document.size(); i++) {
        if (contains(document[i], {"\n", "\r"})) {
            lines.push_back(document.substr(prevIdx + 1, i - prevIdx - 1));
            prevIdx = i;
        }
    }
    lines.push_back(document.substr(prevIdx + 1, document.size()));
}
